<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Infinite Powder Infinity Animation</title>
<style>
  html,body { height:100%; margin:0; background:#030310; }
  canvas { display:block; width:100%; height:100%; }
  /* small UI */
  .ui {
    position:fixed; left:12px; top:12px; z-index:20;
    color:#e6f7ff; font-family:Inter,system-ui,Segoe UI,Roboto,Arial;
    background:rgba(0,0,0,0.25); padding:8px; border-radius:8px;
    backdrop-filter: blur(6px);
  }
  .ui label{ font-size:12px; display:block; margin:4px 0; }
  .ui input[type=range]{ width:160px; }
  .ui button{ margin-top:6px; padding:6px 10px; border-radius:6px; border:0; cursor:pointer; background:#2b9; color:#022;}
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="ui" id="ui" style="opacity: 0;">
  <label>Speed <input id="speed" type="range" min="0.2" max="3" step="0.05" value="1"></label>
  <label>Emission <input id="rate" type="range" min="1" max="160" step="1" value="36"></label>
  <label>Particle size <input id="size" type="range" min="0.6" max="5" step="0.1" value="1.6"></label>
  <label>Fade (tail) <input id="fade" type="range" min="0.02" max="0.25" step="0.01" value="0.08"></label>
  <label>Glow color <input id="color" type="color" value="#ffec7f"></label>
  <div style="display:flex; gap:6px; align-items:center;">
    <button id="pause">Pause</button>
    <button id="clear">Clear</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  // UI elements
  const speedInput = document.getElementById('speed');
  const rateInput = document.getElementById('rate');
  const sizeInput = document.getElementById('size');
  const fadeInput = document.getElementById('fade');
  const colorInput = document.getElementById('color');
  const pauseBtn = document.getElementById('pause');
  const clearBtn = document.getElementById('clear');

  // resize for DPR
  function resize() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * DPR);
    canvas.height = Math.floor(rect.height * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  new ResizeObserver(resize).observe(canvas);
  resize();

  // particle system
  const particles = [];
  let t = 0;             // parameter along infinity path
  let lastTime = 0;
  let running = true;

  // parameters (controlled by UI)
  const params = {
    speed: parseFloat(speedInput.value),         // path speed multiplier
    emitRate: parseInt(rateInput.value, 10),    // how many particles per frame when emitting
    baseSize: parseFloat(sizeInput.value),
    fadeAlpha: parseFloat(fadeInput.value),     // rectangle alpha used to fade the canvas -> controls tail length
    color: colorInput.value,
  };

  // helpers
  function rand(min, max){ return Math.random()*(max-min)+min; }
  function pickColorHex(hex, alpha=1){
    // convert #rrggbb to rgba string
    const r=parseInt(hex.slice(1,3),16);
    const g=parseInt(hex.slice(3,5),16);
    const b=parseInt(hex.slice(5,7),16);
    return `rgba(${r},${g},${b},${alpha})`;
  }

  // parametric infinity (figure-eight) path (Lissajous-style)
  // returns coords centered at canvas center
//   function pathPoint(tt, a) {
//     // a: scale, tt: parameter
//     // use x = a * sin(tt), y = a * sin(2*tt)/2 => nice figure-eight
//     const x = a * Math.sin(tt);
//     const y = a * (Math.sin(2 * tt) / 2);
//     return { x, y };
//   }
function pathPoint(tt, a) {
    const x = a * Math.sin(tt);       // horizontal amplitude
    const y = a * Math.sin(2*tt)/2;  // vertical amplitude closer to horizontal
    return { x, y };
}

  // create particles at an origin with random outward velocities
  function emit(x, y, count) {
    for (let i=0;i<count;i++){
      const ang = Math.random()*Math.PI*2;
      // radial velocity with bias outward from path-direction: small
      const speed = rand(8, 80) * (0.5 + Math.random()*0.7); // px / sec-ish
      particles.push({
        x, y,
        vx: Math.cos(ang)*speed,
        vy: Math.sin(ang)*speed,
        life: rand(0.6, 2.4),   // seconds
        age: 0,
        size: Math.max(0.6, rand(0.2, 1.2) * params.baseSize),
        hue: params.color,
        spin: rand(-1,1),
        alpha: 1
      });
    }
  }

  // main loop
  function frame(time) {
    if (!lastTime) lastTime = time;
    const dt = (time - lastTime) / 1000; // seconds
    lastTime = time;

    // update params from UI (smoothly)
    params.speed = parseFloat(speedInput.value);
    params.emitRate = parseInt(rateInput.value, 10);
    params.baseSize = parseFloat(sizeInput.value);
    params.fadeAlpha = parseFloat(fadeInput.value);
    params.color = colorInput.value;

    // draw a translucent rect to slowly fade previous frames -> creates tails
    ctx.fillStyle = `rgba(2,3,6,${params.fadeAlpha})`; // near-black with alpha
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillRect(0,0,canvas.width/DPR, canvas.height/DPR);

    // additive drawing for glow
    ctx.globalCompositeOperation = 'lighter';

    // compute emitter position (centered)
    const centerX = canvas.width / DPR / 2;
    const centerY = canvas.height / DPR / 2;
    // scale relative to smaller dimension
    const minSide = Math.min(canvas.width/DPR, canvas.height/DPR);
    const amplitude = minSide * 0.45; // figure-eight size
    // increment t based on speed (parametric)
    t += dt * (0.8 * params.speed);

    const p = pathPoint(t, amplitude);
    const emitterX = centerX + p.x;
    const emitterY = centerY + p.y;

    // emit particles (spray)
    // to create a burst-y 'powder' effect: emit random count each frame based on emitRate
    const burst = Math.max(1, Math.round(params.emitRate * (0.6 + Math.random()*0.8)));
    emit(emitterX, emitterY, burst);

    // draw small faint 'emitter spark' (optional)
    ctx.beginPath();
    ctx.fillStyle = pickColorHex(params.color, 0.9);
    ctx.arc(emitterX, emitterY, 1.6 * (params.baseSize/2), 0, Math.PI*2);
    ctx.fill();

    // update & draw particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const pa = particles[i];
      // simple physics: apply slight drag
      const drag = 1 - Math.min(0.99, 0.3 * dt);
      pa.vx *= drag;
      pa.vy *= drag;
      // gravity-like downward pull to add curvature (tiny)
      pa.vy += 16 * dt * (0.05 + Math.random()*0.15);

      pa.x += pa.vx * dt;
      pa.y += pa.vy * dt;
      pa.age += dt;
      const lifeRatio = pa.age / pa.life;
      pa.alpha = Math.max(0, 1 - lifeRatio);

      // draw as tiny glowing square (pixel-like) with soft blur via shadow
      ctx.save();
      ctx.translate(pa.x, pa.y);
      ctx.rotate(pa.spin * lifeRatio * Math.PI);
      ctx.globalAlpha = pa.alpha * 0.9;
      ctx.shadowBlur = Math.max(0, 12 * pa.alpha * (params.baseSize/2));
      ctx.shadowColor = pickColorHex(pa.hue, Math.min(0.9, pa.alpha));
      // draw a filled rectangle small for 'pixels'
      const s = pa.size;
      ctx.fillStyle = pickColorHex(pa.hue, 0.95);
      ctx.fillRect(-s/2, -s/2, s, s);
      ctx.restore();

      // remove dead particles
      if (pa.age >= pa.life || pa.alpha <= 0.01) {
        particles.splice(i, 1);
      }
    }

    // optionally show faint path line for debugging (commented-out)
/*
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.beginPath();
    for (let tt=0; tt<Math.PI*2; tt += 0.02) {
      const q = pathPoint(tt, amplitude);
      const sx = centerX + q.x;
      const sy = centerY + q.y;
      if (tt === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
    }
    ctx.stroke();
*/

    if (running) requestAnimationFrame(frame);
  }

  // start animation
  requestAnimationFrame(frame);

  // pause/resume
  pauseBtn.addEventListener('click', () => {
    running = !running;
    if (running) {
      lastTime = 0;
      requestAnimationFrame(frame);
      pauseBtn.textContent = 'Pause';
    } else {
      pauseBtn.textContent = 'Resume';
    }
  });

  // clear (instant wipe)
  clearBtn.addEventListener('click', () => {
    ctx.clearRect(0,0,canvas.width/DPR, canvas.height/DPR);
    particles.length = 0;
  });

  // small friendly UX: spacebar toggles pause
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') { e.preventDefault(); pauseBtn.click(); }
  });

  // responsiveness: when page becomes hidden, pause to save CPU (but don't lose canvas)
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      running = false;
      pauseBtn.textContent = 'Resume';
    } else {
      running = true;
      lastTime = 0;
      requestAnimationFrame(frame);
      pauseBtn.textContent = 'Pause';
    }
  });

})();
</script>
</body>
</html>

